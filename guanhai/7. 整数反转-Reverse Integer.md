# [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

## 题目

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

```
输入: 123
输出: 321
```

示例 2:

```
输入: -123
输出: -321
```

示例 3:

```
输入: 120
输出: 21
```

注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。



## 解题代码及思路

### 方法：弹出和推入数字 & 溢出前进行检查

#### 思路

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

最大的值与最小的值为：[−2^31, 2^31 − 1]即：[-2147483648, 2147483647]，这两个数值的个位数是8和7.

```java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while(x != 0){
            //取出个位数
            int pop = x % 10;
            //x 去掉个位数
            x /= 10;
            if(rev > Integer.MAX_VALUE/10 || rev == Integer.MAX_VALUE /10 && pop >7) return 0;
            if(rev < Integer.MIN_VALUE/10 || rev == Integer.MIN_VALUE /10 && pop < -8) return 0;
            //存储反转后的数
            rev =rev * 10 +pop;
        }
        return rev;
    }
}
```



#### 改进(仅适用int类型输入的情况)

有两点：

1. while里使用了除法，较慢
2. if 语句有四种可能性，判断pop变量较多余

最大的值与最小的值为：[−2^31, 2^31 − 1]， 即：[-2147483648, 2147483647]

如果y = y * 10 + x % 10溢出，则 y>=214748364 ，

当y=214748364时，输入的值只能为：1463847412，此时不溢出

即：y > 214748364 || y < -214748364 必定溢出

最后这里确实没必要判断最后一位的pop，如果倒过来要溢出的话那么pop值确实要小于7，但是pop值在输入的时候不溢出就已经决定了它只能为1，为2在输入的时候就已经溢出了

```java
class Solution {
    public int reverse(int x) {
        int y = 0;
        while (x != 0) {
            if (y > 214748364 || y < -214748364) {
                return 0;
            }
            y = y * 10 + x % 10;
            x = x / 10;
        }
        return y;
    }
}
```

### 复杂度分析

#### 时间复杂度：

$$
O(\log(x))
$$

，x 中大约有
$$
\log_{10}{x}
$$
​	位数字。

#### 空间复杂度：O(1)

