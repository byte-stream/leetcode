## 1. 两数之和

### 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

### 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]

	方法一：两遍哈希
	class Solution {
	    public int[] twoSum(int[] nums, int target) {
	        Map<Integer,Integer> map = new HashMap<>();
	        for (int i = 0;i<nums.length;i++){
	            map.put(nums[i],i);
	        }
	        for(int i = 0;i<nums.length;i++){
	            Integer subtract = target - nums[i];
	            if(map.containsKey(subtract) && map.get(subtract) != i){
	                return new int []{i,map.get(subtract)};
	            }
	        }
	        throw new IllegalArgumentException("No two sum solution");
	    }
	}

### 分析：哈希表通过以空间换取速度的方式，将查找时间从O(n)下降到O(1)，通过两次循环，第一次将每个元素的值和索引添加到哈希表，第二次查找对应的值是否在表中，而且不能是本身，如果存在就返回两个元素的下标，return new int[] {i,map.get(元素)};

### 复杂度分析：

	时间复杂度：O(n)，
	我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。
	
	空间复杂度：O(n)，
	所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。

-----

	方法二：一遍哈希
	class Solution {
	    public int[] twoSum(int[] nums, int target) {
	        Map<Integer,Integer> map = new HashMap<>();
	        for (int i = 0;i<nums.length;i++){
	            int subtract = target - nums[i];
	            if(map.containsKey(subtract) && map.get(subtract)!=i){
	                return new int [] {map.get(subtract),i};
	            }
	            map.put(nums[i],i);
	        }
	        throw new IllegalArgumentException("No two sum solution");
	    }
	}


* 复杂度和前者一样。

---
	方法三：暴力解法
	class Solution {
	    public int[] twoSum(int[] nums, int target) {
	        for (int i =0 ;i<nums.length-1;i++){
	            int subtract = target - nums[i];
	            for(int j = i+1;j<nums.length;j++){
	                if(subtract == nums[j]){
	                    return new int [] {i,j};
	                }
	            }
	        }
	        throw new IllegalArgumentException("传入参数有误");
	    }
	}

### 分析：两次遍历数组，时间复杂度为O(n^2),空间复杂度为O(1)
---

	方法四：Python两遍哈希
	class Solution:
	    def twoSum(self, nums: List[int], target: int) -> List[int]:
	        hashmap = {}
	        for index,value in enumerate(nums):
	            hashmap[value] = index
	        for i,v in enumerate(nums):
	            if hashmap.get(target - v)!=None and hashmap.get(target - v)!=i:
	                return [i,hashmap.get(target - v)]

### 复杂度和方法一一样。


